
[comment]: # (pedac.md)

# Problem Solving with PEDAC - 9/24/2017

### P: Understand the *P*roblem
Understanding the problem well is usually half or more of the solution. Don't put this step off - do it *first* and do it *thoroughly* and *well*! Make sure you don't get distracted here, or at any other step; doing one thing at a time reduces cognitive load and helps you stay efficient and mentally sharp.

* Take notes as the problem is being described.
* If requirements are shown with examples, those examples need to be described in computational terms.
* Be especially alert for *implicit knowledge*! It needs to be captured and converted to explicit rules declared in computational terms.
* Identify and define important terms and concepts.

Ask questions to verify your understanding of the problem! (This also gives interviewers more data points by which to assess you.) Especially ask about how you should handle unexpected behavior e.g. errors, bad input, etc. Don't assume it should be handled a specific or convenient way.

### E: *E*xamples and Test Cases
Use these (for both *input* and *output*) immediately to verify your understanding of the problem, and record them to later verify your solution functions correctly.
Types of examples to flesh out:
1. "Happy Paths": simple requirements with obvious results, especially useful for achieving and checking minimum baseline functionality.
2. Edge Cases/Boundary Conditions: explore thoroughly for these and *ask questions*!
3. Failures and Bad input

**The boundary between #2 and #3 can be blurry - ask!**

### D: *D*ata Structures
How will you represent the input data? Do any **key** rules or requirements direct you to a specific data structure? If you get stuck, consider compound data structures.

### A: *A*lgorithm
Describe the steps to solve the problem as you understand it. Describe your algorithm in terms of your chosen data structure! This requires that you're fluent with core data structures.
* **Manage your energy!** Find the hardest part of your solution and tackle it first!
* Rely on built-in language abstractions.
* Avoid solving big problems! Break them down into smaller problems.
* Try to solve a smaller problem in 1-2 sentences; if you're not able to do so, raise your level of abstraction and break down this medium problem into even smaller pieces.
* Don't hesitate to create helper methods to handle detailed or repeated steps.


### C: *C*ode it!
Check the building blocks of your solution and run your code incrementally and often so that bugs and misunderstandings don't compound.
